"""A compiled JSONPath ready to be applied to a JSON-like value."""

from __future__ import annotations

from typing import TYPE_CHECKING
from typing import Iterable
from typing import Iterator

from .filter_expressions import Expression
from .filter_expressions import FilterQuery
from .node import JSONPathNode
from .node import JSONPathNodeList
from .segments import JSONPathRecursiveDescentSegment
from .selectors import Filter
from .selectors import IndexSelector
from .selectors import NameSelector
from .selectors import SingularQuerySelector

if TYPE_CHECKING:
    from liquid2 import TokenT

    from .environment import JSONValue
    from .environment import _JSONPathEnvironment
    from .segments import JSONPathSegment
    from .selectors import JSONPathSelector


class JSONPathQuery:
    """A compiled JSONPath expression ready to be applied to a JSON-like value.

    Arguments:
        env: The `JSONPathEnvironment` this query is bound to.
        segments: An iterable of `JSONPathSelector` objects, as generated by
            a `Parser`.

    Attributes:
        env: The `JSONPathEnvironment` this query is bound to.
        segments: The `JSONPathSegment` instances that make up this query.
    """

    __slots__ = ("env", "segments", "token")

    def __init__(
        self,
        *,
        env: _JSONPathEnvironment,
        segments: tuple[JSONPathSegment, ...],
    ) -> None:
        self.env = env
        self.segments = segments

        if segments:
            self.token: TokenT | None = segments[0].token
        else:
            self.token = None

    def __str__(self) -> str:
        # TODO: test
        s = "".join(str(segment) for segment in self.segments)
        if s.startswith(("[", "..")):
            return "$" + s
        if s.startswith("."):
            return s[1:]
        return s

    def __hash__(self) -> int:
        return hash(self.segments)

    def finditer(
        self,
        value: JSONValue,
    ) -> Iterable[JSONPathNode]:
        """Generate `JSONPathNode` instances for each match of this query in value.

        Arguments:
            value: JSON-like data to query, as you'd get from `json.load`.

        Returns:
            An iterator yielding `JSONPathNode` objects for each match.

        Raises:
            JSONPathSyntaxError: If the query is invalid.
            JSONPathTypeError: If a filter expression attempts to use types in
                an incompatible way.
        """
        nodes: Iterable[JSONPathNode] = [
            JSONPathNode(
                value=value,
                location=(),
                root=value,
            )
        ]

        for segment in self.segments:
            nodes = segment.resolve(nodes)

        return nodes

    def find(
        self,
        value: JSONValue,
    ) -> JSONPathNodeList:
        """Apply this JSONPath expression to JSON-like _value_ and return a node list.

        Arguments:
            value: JSON-like data to query, as you'd get from `json.load`.

        Returns:
            A list of `JSONPathNode` instance.

        Raises:
            JSONPathSyntaxError: If the query is invalid.
            JSONPathTypeError: If a filter expression attempts to use types in
                an incompatible way.
        """
        return JSONPathNodeList(self.finditer(value))

    apply = find

    def find_one(self, value: JSONValue) -> JSONPathNode | None:
        """Return the first node from applying this query to _value_.

        Arguments:
            value: JSON-like data to query, as you'd get from `json.load`.

        Returns:
            The first available `JSONPathNode` instance, or `None` if there
                are no matches.

        Raises:
            JSONPathSyntaxError: If the query is invalid.
            JSONPathTypeError: If a filter expression attempts to use types in
                an incompatible way.
        """
        try:
            return next(iter(self.finditer(value)))
        except StopIteration:
            return None

    def singular_query(self) -> bool:
        """Return `True` if this JSONPath expression is a singular query."""
        for segment in self.segments:
            if isinstance(segment, JSONPathRecursiveDescentSegment):
                return False

            if len(segment.selectors) == 1 and isinstance(
                segment.selectors[0], (NameSelector, IndexSelector)
            ):
                continue

            return False

        return True

    def empty(self) -> bool:
        """Return `True` if this query has no segments."""
        return not bool(self.segments)

    def children(self) -> list[JSONPathQuery]:
        """Return a list of child queries from this query.

        Child queries are those found in filter selectors and singular query selectors.
        """
        children: list[JSONPathQuery] = []

        for segment in self.segments:
            for selector in segment.selectors:
                if isinstance(selector, SingularQuerySelector):
                    children.append(selector.query)
                elif isinstance(selector, Filter):
                    children.extend(self._find_filter_queries(selector.expression))

        return children

    def _find_filter_queries(self, root: Expression) -> Iterator[JSONPathQuery]:
        for child in root.children():
            if isinstance(child, FilterQuery):
                yield child.query
            self._find_filter_queries(child)

    def head(self) -> JSONPathSelector | None:
        """Return the first selector from this query."""
        try:
            return self.segments[0].selectors[0]
        except IndexError:
            return None

    def tail(self) -> JSONPathSelector | None:
        """Return the last selector from this query."""
        try:
            return self.segments[-1].selectors[-1]
        except IndexError:
            return None
