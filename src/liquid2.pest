liquid = _{ SOI ~ (markup | content)* ~ EOI }
markup = _{ comment | tag | output_statement }

tag              = _{ raw_tag | end_tag | standard_tag | common_tag }
output_statement =  { statement_start ~ filtered_expr ~ statement_end }
comment          =  { "{" ~ comment_hashes ~ WC ~ comment_text ~ WC ~ POP ~ "}" }
comment_hashes   =  { PUSH("#"+) }
comment_text     =  { (!(WC ~ PEEK ~ "}") ~ ANY)* }
content          =  { (!("{{" | "{%" | "{#") ~ ANY)+ }

tag_start       = _{ "{%" ~ WC ~ S }
tag_end         = _{ S ~ WC ~ "%}" }
statement_start = _{ "{{" ~ WC ~ S }
statement_end   = _{ S ~ WC ~ "}}" }

// whitespace control
WC = { ("+" | "-" | "~")? }

// NOTE: "\n" and "\r" are not allowed in line expressions.
B  = _{ "\x20" | "\x09" | "\x0A" | "\x0D" }
S  = _{ B* }
s  = _{ B+ }
LS = _{ ("\x20" | "\x09")* }
ls = _{ ("\x20" | "\x09")+ }

// TODO: string interpolation?
// NOTE: borrowing literals from JSONPath
primitive = _{
    number
  | multiline_string_literal
  | true_literal
  | false_literal
  | "null"
  | "nil"
  | range
  | query
}

line_primitive = _{
    number
  | string_literal
  | true_literal
  | false_literal
  | "null"
  | "nil"
  | range
  | query
}

// NOTE: borrowing int from JSONPath
// NOTE: range literals can't contain newlines
// XXX: range integers can be negative, but start must be less than stop, even when reversed
range = { "(" ~ LS ~ int ~ LS ~ ".." ~ LS ~ int ~ LS ~ ")" }

multiline_string_literal = _{
    ("\x22" ~ multiline_double_quoted ~ "\x22")
  | ("\x27" ~ multiline_single_quoted ~ "\x27")
}

multiline_double_quoted = { multiline_double_quoted_char* }
multiline_single_quoted = { multiline_single_quoted_char* }

multiline_double_quoted_char = _{
    multiline_unescaped
  | "\x27"
  | (ESC ~ "\x22")
  | (ESC ~ escapable)
}

multiline_single_quoted_char = _{
    multiline_unescaped
  | "\x22"
  | (ESC ~ "\x27")
  | (ESC ~ escapable)
}

multiline_unescaped = _{
    "\u{0A}"
  | '\u{20}'..'\u{21}'
  | '\u{23}'..'\u{26}'
  | '\u{28}'..'\u{5B}'
  | '\u{5D}'..'\u{D7FF}'
  | '\u{E000}'..'\u{10FFFF}'
}

// NOTE: borrowing name_char from JSONPath
identifier = { name_first ~ name_char* }

filtered_expr    =  { primitive ~ filters ~ (s ~ inline_condition)? }
filters          =  { (S ~ filter)* }
inline_condition =  { "if" ~ s ~ boolean_expr ~ (s ~ "else" ~ s ~ alternative)? ~ S ~ tail_filters? }
alternative      =  { primitive ~ filters }
filter           =  { "|" ~ S ~ filter_expr }
tail_filters     =  { S ~ "||" ~ S ~ tail_filter ~ (S ~ "|" ~ S ~ tail_filter)* }
tail_filter      =  { filter_expr }
filter_expr      = _{ filter_name ~ S ~ (":" ~ S ~ common_arguments)? }
filter_name      =  { function_name_first ~ function_name_char* }

common_arguments    =  { common_argument ~ (S ~ "," ~ S ~ common_argument)* }
common_argument     = _{ keyword_argument | positional_argument }
positional_argument =  { primitive }

// NOTE: `=` as well as `:`
keyword_argument = { keyword ~ S ~ (":" | "=") ~ S ~ primitive }
keyword          = { function_name_first ~ function_name_char* }

boolean_expr       =  { boolean_or_expr }
boolean_or_expr    =  { boolean_and_expr ~ (s ~ "or" ~ s ~ boolean_and_expr)* }
boolean_and_expr   =  { boolean_basic_expr ~ (s ~ "and" ~ s ~ boolean_basic_expr)* }
boolean_basic_expr = _{ logical_not | primitive | grouped_expr | compare_expr | membership_expr }
logical_not        =  { "not" ~ s ~ (primitive | grouped_expr) }
grouped_expr       =  { "(" ~ S ~ boolean_expr ~ S ~ ")" }
compare_expr       =  { primitive ~ S ~ compare_op ~ S ~ primitive }
membership_expr    =  { primitive ~ S ~ membership_op ~ S ~ primitive }

compare_op = {
    "=="
  | "!="
  | "<>"
  | "<="
  | ">="
  | "<"
  | ">"
}

membership_op = {
    "contains"
  | "in"
  | "not contains"
  | "not in"
}

/* Tags */
// TODO: raw in `{% liquid %}`?
raw_tag          =  { tag_start ~ "raw" ~ tag_end ~ raw_content ~ tag_start ~ "endraw" ~ tag_end }
raw_content      =  { raw_content_char* }
raw_content_char = _{ !(tag_start ~ "endraw" ~ tag_end) ~ ANY }

// NOTE: borrowing function_name from JSONPath
tag_name     = { function_name_first ~ function_name_char* }
end_tag      = { tag_start ~ "end" ~ tag_name ~ tag_end }
standard_tag = { tag_start ~ standard_tag_expr ~ tag_end }

// NOTE: ifchanged is excluded
// NOTE: tablerow is excluded
// NOTE: comment is excluded
standard_tag_expr = _{
    assign_expr
  | capture_expr
  | case_expr
  | when_expr
  | else_expr
  | cycle_expr
  | decrement_expr
  | increment_expr
  | echo_expr
  | for_expr
  | break_expr
  | continue_expr
  | if_expr
  | elsif_expr
  | unless_expr
  | include_expr
  | render_expr
  | liquid_expr
}

assign_expr = _{ assign ~ s ~ identifier ~ S ~ "=" ~ S ~ filtered_expr }
assign      =  { "assign" }

capture_expr = _{ capture ~ s ~ identifier }
capture      =  { "capture" }

case_expr = _{ case ~ s ~ primitive }
case      =  { "case" }

when_expr = _{ when ~ s ~ primitive ~ ((S ~ "," ~ S) | (s ~ "or" ~ s) ~ primitive)* }
when      =  { "when" }

else_expr = _{ else }
else      =  { "else" }

cycle_expr  = _{ cycle ~ s ~ (cycle_group ~ S ~ ":" ~ S)? ~ primitive ~ (S ~ "," ~ S ~ primitive)* }
cycle_group = @{ string_literal }
cycle       =  { "cycle" }

decrement_expr = _{ decrement ~ s ~ identifier }
decrement      =  { "decrement" }

increment_expr = _{ increment ~ s ~ identifier }
increment      =  { "increment" }

echo_expr = _{ echo ~ s ~ filtered_expr }
echo      =  { "echo" }

// NOTE: comma or space separated args
// NOTE: args can appear in any order (unlike Shopify/Liquid in strict mode)
// NOTE: if duplicated, the latest argument is used
for_expr          = _{ for_ ~ s ~ identifier ~ s ~ "in" ~ s ~ primitive ~ (s ~ for_tag_arguments)? }
for_tag_arguments =  { for_tag_argument ~ ((s | (S ~ "," ~ S)) ~ for_tag_argument)* }
for_tag_argument  = _{ keyword_argument | positional_argument }
for_              =  { "for" }

break_expr = { break_ }
break_     = { "break" }

continue_expr = { continue_ }
continue_     = { "continue" }

if_expr = _{ if_ ~ s ~ boolean_expr }
if_     =  { "if" }

elsif_expr = _{ elsif ~ s ~ boolean_expr }
elsif      =  { "elsif" }

unless_expr = _{ unless ~ s ~ boolean_expr }
unless      =  { "unless" }

// NOTE: no leading comma allowed in arguments
include_expr          = _{ include ~ s ~ primitive ~ (s ~ include_tag_arguments)? }
include               =  { "include" }
include_tag_arguments =  { (include_with | include_for)? ~ common_arguments? }
include_with          =  { "with" ~ s ~ primitive ~ (s ~ "as" ~ s ~ identifier)? }
include_for           =  { "for" ~ s ~ primitive ~ (s ~ "as" ~ s ~ identifier)? }

render_expr = _{ render ~ s ~ multiline_string_literal ~ (s ~ include_tag_arguments)? }
render      =  { "render" }

liquid_expr  = _{ liquid_tag ~ (s ~ line_exprs)? }
liquid_tag   =  { "liquid" }
line_exprs   = _{ line_expr ~ (LS ~ "\x0A"+ ~ LS ~ line_expr)* }
line_expr    = _{ line_end_tag | line_standard_tag_expr | line_common_tag_expr }
line_end_tag =  { "end" ~ tag_name }

// For non-standard tags aka tag extensions
common_tag      = { tag_start ~ common_tag_expr ~ tag_end }
common_tag_expr = { tag_name ~ s ~ (common_argument ~ (S ~ "," ~ S ~ common_argument)*)? }

/* Newline sensitive expressions for the "liquid" tag. */
line_filtered_expr    =  { line_primitive ~ line_filters ~ (ls ~ line_inline_condition)? }
line_filters          =  { (LS ~ line_filter)* }
line_inline_condition =  { "if" ~ ls ~ line_boolean_expr ~ (ls ~ "else" ~ ls ~ line_alternative)? ~ LS ~ line_tail_filters? }
line_alternative      =  { line_primitive ~ filters }
line_filter           =  { "|" ~ LS ~ line_filter_expr }
line_tail_filters     =  { LS ~ "||" ~ LS ~ line_tail_filter ~ (LS ~ "|" ~ LS ~ line_tail_filter)* }
line_tail_filter      =  { line_filter_expr }
line_filter_expr      = _{ filter_name ~ LS ~ (":" ~ LS ~ line_common_arguments)? }

line_common_arguments    =  { line_common_argument ~ (LS ~ "," ~ LS ~ line_common_argument)* }
line_common_argument     = _{ line_keyword_argument | line_positional_argument }
line_positional_argument =  { line_primitive }
line_keyword_argument    =  { keyword ~ LS ~ (":" | "=") ~ LS ~ line_primitive }

line_boolean_expr       =  { line_boolean_or_expr }
line_boolean_or_expr    =  { line_boolean_and_expr ~ (ls ~ "or" ~ ls ~ line_boolean_and_expr)* }
line_boolean_and_expr   =  { line_boolean_basic_expr ~ (ls ~ "and" ~ ls ~ line_boolean_basic_expr)* }
line_boolean_basic_expr = _{ line_logical_not | line_primitive | line_grouped_expr | line_compare_expr | line_membership_expr }
line_logical_not        =  { "not" ~ ls ~ (line_primitive | line_grouped_expr) }
line_grouped_expr       =  { "(" ~ LS ~ line_boolean_expr ~ LS ~ ")" }
line_compare_expr       =  { line_primitive ~ LS ~ compare_op ~ LS ~ line_primitive }
line_membership_expr    =  { line_primitive ~ LS ~ membership_op ~ LS ~ line_primitive }

// NOTE: liquid is not allowed inside liquid
// NOTE: raw is not allowed inside liquid
// TODO: line comment
line_standard_tag_expr = {
    line_assign_expr
  | line_capture_expr
  | line_case_expr
  | line_when_expr
  | line_else_expr
  | line_cycle_expr
  | line_decrement_expr
  | line_increment_expr
  | line_echo_expr
  | line_for_expr
  | break_expr
  | continue_expr
  | line_if_expr
  | line_elsif_expr
  | line_unless_expr
  | line_include_expr
  | line_render_expr
}

line_assign_expr    = _{ assign ~ ls ~ identifier ~ LS ~ "=" ~ LS ~ filtered_expr }
line_capture_expr   = _{ capture ~ ls ~ identifier }
line_case_expr      = _{ case ~ ls ~ line_primitive }
line_when_expr      = _{ when ~ ls ~ line_primitive ~ ((LS ~ "," ~ LS) | (ls ~ "or" ~ ls) ~ line_primitive)* }
line_else_expr      = _{ else }
line_cycle_expr     = _{ cycle ~ ls ~ (cycle_group ~ LS ~ ":" ~ LS)? ~ line_primitive ~ (LS ~ "," ~ LS ~ line_primitive)* }
line_decrement_expr = _{ decrement ~ ls ~ identifier }
line_increment_expr = _{ increment ~ ls ~ identifier }
line_echo_expr      = _{ echo ~ ls ~ line_filtered_expr }

// NOTE: comma or space separated args
// NOTE: args can appear in any order (unlike Shopify/Liquid in strict mode)
// NOTE: if duplicated, the latest argument is used
line_for_expr          = _{ for_ ~ ls ~ identifier ~ ls ~ "in" ~ ls ~ line_primitive ~ (ls ~ line_for_tag_arguments)? }
line_for_tag_arguments =  { line_for_tag_argument ~ ((ls | (LS ~ "," ~ LS)) ~ line_for_tag_argument)* }
line_for_tag_argument  = _{ line_keyword_argument | positional_argument }

line_if_expr     = _{ if_ ~ ls ~ line_boolean_expr }
line_elsif_expr  = _{ elsif ~ ls ~ line_boolean_expr }
line_unless_expr = _{ unless ~ ls ~ line_boolean_expr }

// NOTE: no leading comma allowed in arguments
line_include_expr          = _{ include ~ ls ~ line_primitive ~ (ls ~ line_include_tag_arguments)? }
line_include_tag_arguments =  { (line_include_with | line_include_for)? ~ line_common_arguments? }
line_include_with          =  { "with" ~ ls ~ line_primitive ~ (ls ~ "as" ~ ls ~ identifier)? }
line_include_for           =  { "for" ~ ls ~ line_primitive ~ (ls ~ "as" ~ ls ~ identifier)? }

line_render_expr = _{ render ~ ls ~ string_literal ~ (ls ~ line_include_tag_arguments)? }

line_common_tag_expr = { tag_name ~ ls ~ (line_common_argument ~ (LS ~ "," ~ LS ~ line_common_argument)*)? }

/* Modified JSONPath */
// TODO: move implicit_root_segment so we just have segments*
query = {
    (root_identifier ~ segments)
  | (implicit_root_segment ~ segments)
}

root_identifier = _{ "$" }
segments        = _{ (S ~ segment)* }

selector = _{
    name_selector
  | wildcard_selector
  | slice_selector
  | index_selector
  | filter_selector
  | singular_query_selector
}

name_selector = _{ string_literal }

string_literal = _{
    ("\x22" ~ double_quoted ~ "\x22")
  | ("\x27" ~ single_quoted ~ "\x27")
}

double_quoted = { double_quoted_char* }
single_quoted = { single_quoted_char* }

double_quoted_char = _{
    unescaped
  | "\x27"
  | (ESC ~ "\x22")
  | (ESC ~ escapable)
}

single_quoted_char = _{
    unescaped
  | "\x22"
  | (ESC ~ "\x27")
  | (ESC ~ escapable)
}

ESC = _{ "\x5C" }

unescaped = _{
    '\u{20}'..'\u{21}'
  | '\u{23}'..'\u{26}'
  | '\u{28}'..'\u{5B}'
  | '\u{5D}'..'\u{D7FF}'
  | '\u{E000}'..'\u{10FFFF}'
}

escapable = _{
    "\x62"
  | "\x66"
  | "\x6E"
  | "\x72"
  | "\x74"
  | "/"
  | "\\"
  | ("\x75" ~ hexchar)
}

hexchar = _{
    non_surrogate
  | (high_surrogate ~ "\\u" ~ low_surrogate)
}

non_surrogate = _{
    ((ASCII_DIGIT | ^"A" | ^"B" | ^"C" | ^"E" | ^"F") ~ ASCII_HEX_DIGIT{3})
  | (^"D" ~ '\u{30}'..'\u{37}' ~ ASCII_HEX_DIGIT{2})
}

high_surrogate    = _{ ^"D" ~ ("8" | "9" | ^"A" | ^"B") ~ ASCII_HEX_DIGIT{2} }
low_surrogate     = _{ ^"D" ~ (^"C" | ^"D" | ^"E" | ^"F") ~ ASCII_HEX_DIGIT{2} }
wildcard_selector =  { "*" }
index_selector    = @{ int }
int               =  { "0" | ("-"? ~ ASCII_NONZERO_DIGIT ~ ASCII_DIGIT*) }
slice_selector    =  { (start ~ S)? ~ ":" ~ S ~ (stop ~ S)? ~ (":" ~ (S ~ step)?)? }
start             = @{ int }
stop              = @{ int }
step              = @{ int }
filter_selector   =  { "?" ~ S ~ logical_expr }
logical_expr      = _{ logical_or_expr }
logical_or_expr   =  { logical_and_expr ~ (S ~ "||" ~ S ~ logical_and_expr)* }
logical_and_expr  =  { basic_expr ~ (S ~ "&&" ~ S ~ basic_expr)* }

singular_query_selector = {
    (root_identifier ~ singular_query_segments)
  | ((implicit_root_name_segment | index_segment) ~ singular_query_segments)
}

basic_expr = _{
    paren_expr
  | comparison_expr
  | test_expr
}

paren_expr              =  { (logical_not_op ~ S)? ~ "(" ~ S ~ logical_expr ~ S ~ ")" }
logical_not_op          =  { "!" }
test_expr               =  { (logical_not_op ~ S)? ~ (filter_query | function_expr) }
filter_query            = _{ rel_query | root_query }
root_query              =  { query }
rel_query               =  { current_node_identifier ~ segments }
current_node_identifier = _{ "@" }
comparison_expr         =  { comparable ~ S ~ comparison_op ~ S ~ comparable }

literal = _{
    number
  | string_literal
  | true_literal
  | false_literal
  | null
}

comparable = _{
    literal
  | singular_query
  | function_expr
}

comparison_op = {
    "=="
  | "!="
  | "<="
  | ">="
  | "<"
  | ">"
}

// TODO: silencing singular_query and/or singular_query_segments leads to
// undesirable error messages.

singular_query          = _{ rel_singular_query | abs_singular_query }
rel_singular_query      =  { current_node_identifier ~ singular_query_segments }
abs_singular_query      =  { root_identifier ~ singular_query_segments }
singular_query_segments = _{ (S ~ (name_segment | index_segment | singular_query_segment))* }
singular_query_segment  =  { "[" ~ singular_query_selector ~ "]" }

// TODO: whitespace?
name_segment = {
    ("[" ~ name_selector ~ "]")
  | ("." ~ member_name_shorthand)
}

// TODO: whitespace?
implicit_root_name_segment = _{
    ("[" ~ name_selector ~ "]")
  | member_name_shorthand
}

index_segment       =  { "[" ~ index_selector ~ "]" }
number              =  { (int | "-0") ~ frac? ~ exp? }
frac                =  { "." ~ ASCII_DIGIT+ }
exp                 =  { ^"e" ~ ("-" | "+")? ~ ASCII_DIGIT+ }
true_literal        =  { "true" }
false_literal       =  { "false" }
null                =  { "null" }
function_name       =  { function_name_first ~ function_name_char* }
function_name_first = _{ ASCII_ALPHA_LOWER }
function_name_char  = _{ function_name_first | "_" | ASCII_DIGIT }

function_expr = {
    function_name ~ "(" ~ S ~ (function_argument ~ (S ~ "," ~ S ~ function_argument)*)? ~ S ~ ")"
}

function_argument = _{
    filter_query
  | logical_expr
  | function_expr
  | literal
}

segment = _{
    child_segment
  | descendant_segment
}

child_segment = {
    bracketed_selection
  | ("." ~ (wildcard_selector | member_name_shorthand))
}

implicit_root_segment = {
    bracketed_selection
  | (wildcard_selector | member_name_shorthand)
}

bracketed_selection   = { "[" ~ S ~ selector ~ (S ~ "," ~ S ~ selector)* ~ S ~ "]" }
member_name_shorthand = { name_first ~ name_char* }

name_first = _{
    ASCII_ALPHA
  | "_"
  | '\u{80}'..'\u{D7FF}'
  | '\u{E000}'..'\u{10FFFF}'
}

name_char = _{ name_first | ASCII_DIGIT }

descendant_segment = {
    ".." ~ (bracketed_selection | wildcard_selector | member_name_shorthand)
}
