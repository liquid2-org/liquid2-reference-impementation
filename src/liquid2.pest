liquid = _{ SOI ~ (markup | content)* ~ EOI }
markup = _{ tag | output_statement | comment }

tag              = _{ raw_tag | end_tag | standard_tag | common_tag }
output_statement =  { statement_start ~ filtered_expr ~ statement_end }
comment          =  { "{" ~ PUSH("#"+) ~ WC ~ comment_text ~ WC ~ POP ~ "}" }
comment_text     =  { (!(WC ~ PEEK ~ "}") ~ ANY)* }
content          =  { (!("{{" | "{%" | "{#") ~ ANY)+ }

tag_start       = _{ "{%" ~ WC ~ S }
tag_end         = _{ S ~ WC ~ "%}" }
statement_start = _{ "{{" ~ WC ~ S }
statement_end   = _{ S ~ WC ~ "}}" }

// whitespace control
WC = { ("+" | "-" | "~")? }

// NOTE: "\n" and "\r" are not allowed in line expressions.
B  = _{ "\x20" | "\x09" | "\x0A" | "\x0D" }
S  = _{ B* }
s  = _{ B+ }
LS = _{ ("\x20" | "\x09")* }
ls = _{ ("\x20" | "\x09")+ }

// TODO: string interpolation?
// NOTE: borrowing literals from JSONPath
primitive = _{
    number
  | multiline_string_literal
  | true_literal
  | false_literal
  | "null"
  | "nil"
  | range
  | query
}

// NOTE: borrowing int from JSONPath
// NOTE: range literals can't contain newlines
// TODO: negative ranges?
range = { "(" ~ LS ~ int ~ LS ~ ".." ~ LS ~ int ~ LS ~ ")" }

multiline_string_literal = _{
    ("\x22" ~ multiline_double_quoted ~ "\x22")
  | ("\x27" ~ multiline_single_quoted ~ "\x27")
}

multiline_double_quoted = { multiline_double_quoted_char* }
multiline_single_quoted = { multiline_single_quoted_char* }

multiline_double_quoted_char = _{
    multiline_unescaped
  | "\x27"
  | (ESC ~ "\x22")
  | (ESC ~ escapable)
}

multiline_single_quoted_char = _{
    multiline_unescaped
  | "\x22"
  | (ESC ~ "\x27")
  | (ESC ~ escapable)
}

multiline_unescaped = _{
    "\u{0A}"
  | '\u{20}'..'\u{21}'
  | '\u{23}'..'\u{26}'
  | '\u{28}'..'\u{5B}'
  | '\u{5D}'..'\u{D7FF}'
  | '\u{E000}'..'\u{10FFFF}'
}

// NOTE: borrowing name_char from JSONPath
identifier = { name_first ~ name_char* }

// TODO: update line filtered_expr to match
filtered_expr    =  { primitive ~ filters ~ (s ~ inline_condition)? }
filters          =  { (S ~ filter)* }
inline_condition =  { "if" ~ s ~ boolean_expr ~ (s ~ "else" ~ s ~ alternative)? ~ S ~ tail_filters }
alternative      =  { primitive ~ filters }
filter           = _{ "|" ~ S ~ filter_expr }
tail_filters     =  { S ~ "||" ~ S ~ filter_expr ~ (S ~ filter)* }
filter_expr      = _{ filter_name ~ S ~ (":" ~ S ~ common_arguments)? }
filter_name      =  { function_name_first ~ function_name_char* }

common_arguments    =  { common_argument ~ (S ~ "," ~ S ~ common_argument)* }
common_argument     = _{ keyword_argument | positional_argument }
positional_argument =  { primitive }

// TODO: allow `=` as well as `:`?
keyword_argument = { keyword ~ S ~ ":" ~ S ~ primitive }
keyword          = { function_name_first ~ function_name_char* }

boolean_expr       = { boolean_or_expr }
boolean_or_expr    = { boolean_and_expr ~ (s ~ "or" ~ s ~ boolean_and_expr)* }
boolean_and_expr   = { boolean_basic_expr ~ (s ~ "and" ~ s ~ boolean_basic_expr)* }
boolean_basic_expr = { logical_not | primitive | grouped_expr | compare_expr | membership_expr }
logical_not        = { "not" ~ s ~ (primitive | grouped_expr) }
grouped_expr       = { "(" ~ S ~ boolean_expr ~ S ~ ")" }
compare_expr       = { primitive ~ S ~ compare_op ~ S ~ primitive }
membership_expr    = { primitive ~ S ~ membership_op ~ S ~ primitive }

compare_op = {
    "=="
  | "!="
  | "<>"
  | "<="
  | ">="
  | "<"
  | ">"
}

membership_op = {
    "contains"
  | "in"
  | "not contains"
  | "not in"
}

/* Tags */
raw_tag          =  { tag_start ~ "raw" ~ tag_end ~ raw_content ~ tag_start ~ "endraw" ~ tag_end }
raw_content      =  { raw_content_char* }
raw_content_char = _{ !(tag_start ~ "endraw" ~ tag_end) ~ ANY }

// NOTE: borrowing function_name from JSONPath
tag_name     = { function_name_first ~ function_name_char* }
end_tag      = { tag_start ~ "end" ~ tag_name ~ tag_end }
standard_tag = { tag_start ~ standard_tag_expr ~ tag_end }

// NOTE: ifchanged is excluded
// NOTE: tablerow is excluded
standard_tag_expr = _{
    assign_expr
  | capture_expr
  | case_expr
  | when_expr
  | else_expr
  | cycle_expr
  | decrement_expr
  | increment_expr
  | echo_expr
  | for_expr
  | break_expr
  | continue_expr
  | if_expr
  | elsif_expr
  | unless_expr
  | include_expr
  | render_expr
  | liquid_expr
}

assign_expr = _{ assign ~ s ~ identifier ~ S ~ "=" ~ S ~ filtered_expr }
assign      =  { "assign" }

capture_expr = _{ capture ~ s ~ identifier }
capture      =  { "capture" }

case_expr = _{ case ~ s ~ primitive }
case      =  { "case" }

when_expr = _{ when ~ s ~ primitive ~ ((S ~ "," ~ S) | (s ~ "or" ~ s) ~ primitive)* }
when      =  { "when" }

else_expr = _{ else }
else      =  { "else" }

cycle_expr  = _{ cycle ~ s ~ (cycle_group ~ S ~ ":" ~ S)? ~ primitive ~ (S ~ "," ~ S ~ primitive)* }
cycle_group = @{ primitive }
cycle       =  { "cycle" }

decrement_expr = _{ decrement ~ s ~ identifier }
decrement      =  { "decrement" }

increment_expr = _{ increment ~ s ~ identifier }
increment      =  { "increment" }

echo_expr = _{ echo ~ s ~ filtered_expr }
echo      =  { "echo" }

for_expr          = _{ for ~ s ~ identifier ~ s ~ "in" ~ s ~ primitive ~ (s ~ for_tag_arguments)? }
for_tag_arguments =  { for_tag_argument ~ (s ~ for_tag_argument)* }
for_tag_argument  =  {
    ("limit" ~ S ~ ":" ~ S ~ primitive)
  | ("offset" ~ S ~ ":" ~ S ~ (primitive | "continue"))
  | "reversed"
}
for               =  { "for" }

break_expr    = { "break" }
continue_expr = { "continue" }

if_expr = _{ if ~ s ~ boolean_expr }
if      =  { "if" }

elsif_expr = _{ elsif ~ s ~ boolean_expr }
elsif      =  { "elsif" | "elif" }

unless_expr = _{ unless ~ s ~ boolean_expr }
unless      =  { "unless" }

// NOTE: no leading comma allowed in arguments
include_expr          = _{ include ~ s ~ primitive ~ (s ~ include_tag_arguments)? }
include               =  { " include " }
include_tag_arguments =  { ("with" | "for") ~ s ~ primitive ~ (s ~ "as" ~ s ~ primitive)? ~ common_arguments? }

render_expr = _{ render ~ s ~ primitive ~ (s ~ include_tag_arguments)? }
render      =  { "render" }

liquid_expr = _{ liquid_tag ~ (s ~ line_exprs)? }
liquid_tag  =  { "liquid" }
line_exprs  =  { line_expr ~ (LS ~ "\x0A"+ ~ LS ~ line_expr)* }
line_expr   =  { standard_tag_line_expr | common_line_tag_expr }

// For non-standard tags aka tag extensions
common_tag          = { tag_start ~ common_tag_expr ~ tag_end }
common_tag_expr     = { tag_name ~ s ~ (common_tag_argument ~ (S ~ "," ~ S ~ common_tag_argument)*)? }
common_tag_argument = { keyword_line_argument | keyword | positional_argument }

/* Newline sensitive expressions for the "liquid" tag. */
filtered_line_expr    =  { primitive ~ (LS ~ line_filter)* ~ (ls ~ line_inline_condition)? }
line_inline_condition =  { "if" ~ ls ~ boolean_line_expr ~ (ls ~ "else" ~ ls ~ boolean_line_expr)? ~ (LS ~ line_filter)* ~ (LS ~ line_tail_filter)? }
filter_line_expr      = _{ keyword ~ LS ~ (":" ~ LS ~ common_line_arguments)? }
line_filter           =  { "|" ~ LS ~ filter_line_expr }
line_tail_filter      =  { "||" ~ LS ~ filter_line_expr ~ (LS ~ line_filter)* }

boolean_line_expr       = { boolean_or_line_expr }
boolean_or_line_expr    = { boolean_and_line_expr ~ (ls ~ "or" ~ ls ~ boolean_and_line_expr)* }
boolean_and_line_expr   = { boolean_basic_line_expr ~ (ls ~ "and" ~ ls ~ boolean_basic_expr)* }
boolean_basic_line_expr = { (("not" ~ ls)? ~ (primitive | grouped_line_expr) | compare_line_expr | membership_line_expr) }
grouped_line_expr       = { "(" ~ LS ~ boolean_line_expr ~ LS ~ ")" }
compare_line_expr       = { primitive ~ LS ~ compare_op ~ LS ~ primitive }
membership_line_expr    = { primitive ~ LS ~ membership_op ~ LS ~ primitive }

standard_tag_line_expr = {
    assign_line_expr
  | capture_line_expr
  | case_line_expr
  | when_line_expr
  | else_line_expr
  | cycle_line_expr
  | decrement_line_expr
  | increment_line_expr
  | echo_line_expr
  | for_line_expr
  | break_line_expr
  | continue_line_expr
  | if_line_expr
  | elsif_line_expr
  | unless_line_expr
  | include_line_expr
  | render_line_expr
}

assign_line_expr       = { "assign" ~ ls ~ identifier ~ LS ~ "=" ~ LS ~ filtered_line_expr }
capture_line_expr      = { "capture" ~ ls ~ identifier }
case_line_expr         = { "case" ~ ls ~ primitive }
when_line_expr         = { "when" ~ ls ~ primitive ~ ((LS ~ "," ~ LS) | (ls ~ "or" ~ ls) ~ primitive)* }
else_line_expr         = { "else" }
cycle_line_expr        = { "cycle" ~ ls ~ (cycle_group ~ LS ~ ":" ~ LS)? ~ primitive ~ (LS ~ "," ~ LS ~ primitive)* }
decrement_line_expr    = { "decrement" ~ ls ~ identifier }
increment_line_expr    = { "increment" ~ ls ~ identifier }
echo_line_expr         = { "echo" ~ ls ~ filtered_line_expr }
for_line_expr          = { "for" ~ ls ~ identifier ~ ls ~ "in" ~ ls ~ primitive ~ (ls ~ for_tag_line_arguments)? }
for_tag_line_arguments = { for_tag_line_argument ~ (ls ~ for_tag_line_argument)* }
for_tag_line_argument  = {
    ("limit" ~ LS ~ ":" ~ LS ~ primitive)
  | ("offset" ~ LS ~ ":" ~ LS ~ (primitive | "continue"))
  | "reversed"
}

break_line_expr    = { "break" }
continue_line_expr = { "continue" }
if_line_expr       = { "if" ~ ls ~ boolean_line_expr }
elsif_line_expr    = { ("elsif" | "elif") ~ ls ~ boolean_line_expr }
unless_line_expr   = { "unless" ~ ls ~ boolean_line_expr }

// NOTE: no leading comma allowed in arguments
include_line_expr          = { "include" ~ ls ~ primitive ~ (ls ~ include_tag_line_arguments)? }
include_tag_line_arguments = { ("with" | "for") ~ ls ~ primitive ~ (ls ~ "as" ~ ls ~ primitive)? ~ ls ~ common_line_arguments? }
render_line_expr           = { "render" ~ ls ~ primitive ~ (ls ~ include_tag_line_arguments)? }

common_line_arguments = { common_line_argument ~ (LS ~ "," ~ LS ~ common_line_argument)* }
common_line_argument  = { keyword_line_argument | positional_argument }
keyword_line_argument = { keyword ~ LS ~ ":" ~ LS ~ primitive }

common_line_tag_expr     = { tag_name ~ ls ~ (common_line_tag_argument ~ (LS ~ "," ~ LS ~ common_line_tag_argument)*)? }
common_line_tag_argument = { keyword_line_argument | keyword | positional_argument }

/* Modified JSONPath */
// TODO: move implicit_root_segment so we just have segments*
query = {
    (root_identifier ~ segments)
  | (implicit_root_segment ~ segments)
}

root_identifier = _{ "$" }
segments        = _{ (S ~ segment)* }

selector = _{
    name_selector
  | wildcard_selector
  | slice_selector
  | index_selector
  | filter_selector
  | singular_query_selector
}

name_selector = _{ string_literal }

string_literal = _{
    ("\x22" ~ double_quoted ~ "\x22")
  | ("\x27" ~ single_quoted ~ "\x27")
}

double_quoted = { double_quoted_char* }
single_quoted = { single_quoted_char* }

double_quoted_char = _{
    unescaped
  | "\x27"
  | (ESC ~ "\x22")
  | (ESC ~ escapable)
}

single_quoted_char = _{
    unescaped
  | "\x22"
  | (ESC ~ "\x27")
  | (ESC ~ escapable)
}

ESC = _{ "\x5C" }

unescaped = _{
    '\u{20}'..'\u{21}'
  | '\u{23}'..'\u{26}'
  | '\u{28}'..'\u{5B}'
  | '\u{5D}'..'\u{D7FF}'
  | '\u{E000}'..'\u{10FFFF}'
}

escapable = _{
    "\x62"
  | "\x66"
  | "\x6E"
  | "\x72"
  | "\x74"
  | "/"
  | "\\"
  | ("\x75" ~ hexchar)
}

hexchar = _{
    non_surrogate
  | (high_surrogate ~ "\\u" ~ low_surrogate)
}

non_surrogate = _{
    ((ASCII_DIGIT | ^"A" | ^"B" | ^"C" | ^"E" | ^"F") ~ ASCII_HEX_DIGIT{3})
  | (^"D" ~ '\u{30}'..'\u{37}' ~ ASCII_HEX_DIGIT{2})
}

high_surrogate    = _{ ^"D" ~ ("8" | "9" | ^"A" | ^"B") ~ ASCII_HEX_DIGIT{2} }
low_surrogate     = _{ ^"D" ~ (^"C" | ^"D" | ^"E" | ^"F") ~ ASCII_HEX_DIGIT{2} }
wildcard_selector =  { "*" }
index_selector    = @{ int }
int               =  { "0" | ("-"? ~ ASCII_NONZERO_DIGIT ~ ASCII_DIGIT*) }
slice_selector    =  { (start ~ S)? ~ ":" ~ S ~ (stop ~ S)? ~ (":" ~ (S ~ step)?)? }
start             = @{ int }
stop              = @{ int }
step              = @{ int }
filter_selector   =  { "?" ~ S ~ logical_expr }
logical_expr      = _{ logical_or_expr }
logical_or_expr   =  { logical_and_expr ~ (S ~ "||" ~ S ~ logical_and_expr)* }
logical_and_expr  =  { basic_expr ~ (S ~ "&&" ~ S ~ basic_expr)* }

singular_query_selector = {
    (root_identifier ~ singular_query_segments)
  | ((implicit_root_name_segment | index_segment) ~ singular_query_segments)
}

basic_expr = _{
    paren_expr
  | comparison_expr
  | test_expr
}

paren_expr              =  { (logical_not_op ~ S)? ~ "(" ~ S ~ logical_expr ~ S ~ ")" }
logical_not_op          =  { "!" }
test_expr               =  { (logical_not_op ~ S)? ~ (filter_query | function_expr) }
filter_query            = _{ rel_query | root_query }
root_query              =  { query }
rel_query               =  { current_node_identifier ~ segments }
current_node_identifier = _{ "@" }
comparison_expr         =  { comparable ~ S ~ comparison_op ~ S ~ comparable }

literal = _{
    number
  | string_literal
  | true_literal
  | false_literal
  | null
}

comparable = _{
    literal
  | singular_query
  | function_expr
}

comparison_op = {
    "=="
  | "!="
  | "<="
  | ">="
  | "<"
  | ">"
}

// TODO: silencing singular_query and/or singular_query_segments leads to
// undesirable error messages.

singular_query          = _{ rel_singular_query | abs_singular_query }
rel_singular_query      =  { current_node_identifier ~ singular_query_segments }
abs_singular_query      =  { root_identifier ~ singular_query_segments }
singular_query_segments = _{ (S ~ (name_segment | index_segment | singular_query_segment))* }
singular_query_segment  =  { "[" ~ singular_query_selector ~ "]" }

// TODO: whitespace?
name_segment = {
    ("[" ~ name_selector ~ "]")
  | ("." ~ member_name_shorthand)
}

// TODO: whitespace?
implicit_root_name_segment = _{
    ("[" ~ name_selector ~ "]")
  | member_name_shorthand
}

index_segment       =  { "[" ~ index_selector ~ "]" }
number              =  { (int | "-0") ~ frac? ~ exp? }
frac                =  { "." ~ ASCII_DIGIT+ }
exp                 =  { ^"e" ~ ("-" | "+")? ~ ASCII_DIGIT+ }
true_literal        =  { "true" }
false_literal       =  { "false" }
null                =  { "null" }
function_name       =  { function_name_first ~ function_name_char* }
function_name_first = _{ ASCII_ALPHA_LOWER }
function_name_char  = _{ function_name_first | "_" | ASCII_DIGIT }

function_expr = {
    function_name ~ "(" ~ S ~ (function_argument ~ (S ~ "," ~ S ~ function_argument)*)? ~ S ~ ")"
}

function_argument = _{
    filter_query
  | logical_expr
  | function_expr
  | literal
}

segment = _{
    child_segment
  | descendant_segment
}

child_segment = {
    bracketed_selection
  | ("." ~ (wildcard_selector | member_name_shorthand))
}

implicit_root_segment = {
    bracketed_selection
  | (wildcard_selector | member_name_shorthand)
}

bracketed_selection   = { "[" ~ S ~ selector ~ (S ~ "," ~ S ~ selector)* ~ S ~ "]" }
member_name_shorthand = { name_first ~ name_char* }

name_first = _{
    ASCII_ALPHA
  | "_"
  | '\u{80}'..'\u{D7FF}'
  | '\u{E000}'..'\u{10FFFF}'
}

name_char = _{ name_first | ASCII_DIGIT }

descendant_segment = {
    ".." ~ (bracketed_selection | wildcard_selector | member_name_shorthand)
}
